// -*- C++ -*-
#include "Rivet/Analysis.hh"
#include "Rivet/Projections/FinalState.hh"
#include "Rivet/Projections/FastJets.hh"
#include "Rivet/Projections/DressedLeptons.hh"
#include "Rivet/Projections/TauFinder.hh"
#include "Rivet/Projections/MissingMomentum.hh"
#include "Rivet/Projections/PromptFinalState.hh"
#include "Rivet/Projections/VetoedFinalState.hh"
#include "TFile.h"
#include "./OutputTree.h"

//Analysis code for ttcc processes generated by aMC@NLO

//OutputTree.h should be in the pwd or else change the path in the include line above
//The OutputTree.h file can be found at 
// https://gitlab.cern.ch/carleton-ATLAS/hadron-level-jet-classification/-/blob/master/plotMacros/OutputTree.h

namespace Rivet {


  /// @brief Add a short analysis description here
  class ttcc_plots : public Analysis {
  public:

    /// Constructor
    DEFAULT_RIVET_ANALYSIS_CTOR(ttcc_plots);


    /// @name Analysis methods
    //@{
    /// Book histograms and initialise projections before the run
    void init() {

      // Initialise and register projections

      // The basic final-state projection:
      // all final-state particles within
      // the given eta acceptance
      const FinalState fs(Cuts::abseta < 4.9); 

      declare(UnstableParticles(), "UFS");

      // FinalState of prompt photons and bare muons and electrons in the event
      //true means accept tau decays as prompt
      PromptFinalState photons(Cuts::abspid == PID::PHOTON);
      PromptFinalState bare_leps(Cuts::abspid == PID::ELECTRON || Cuts::abspid == PID::MUON, true);
      
      // Dress the prompt bare leptons with prompt photons within dR < 0.1,
      // and apply some fiducial cuts on the dressed leptons
      Cut lepton_cuts = Cuts::abseta < 2.5 && Cuts::pT > 10*GeV; 
      DressedLeptons dressed_leps(photons, bare_leps, 0.1, lepton_cuts);
      declare(dressed_leps, "lightleptons");


      // Define jets 
      VetoedFinalState vfs(FinalState(Cuts::abseta < 4.5));
      vfs.addVetoOnThisFinalState(dressed_leps);
      FastJets jets(vfs, FastJets::ANTIKT, 0.4, JetAlg::Muons::ALL, JetAlg::Invisibles::NONE);
      declare(jets, "jets");

      // Missing momentum
      declare(MissingMomentum(fs), "MET");
      
      // taus
      declare(TauFinder(), "taus");
		     
      
      // Book histograms
      // specify custom binning
      book(_h["total"], "total",1,0.5,1.5);
      book(_h["cutflow"], "cutflow",8,-0.5,7.5);

      book(_h["CJet1Pt"], "CJet1Pt", 60, 0.0, 300.0);
      book(_h["CJet1Pt_1c"], "CJet1Pt_1c", 60, 0.0, 300.0);
      book(_h["CJet1Pt_2c"], "CJet1Pt_2c", 60, 0.0, 300.0);
      book(_h["CJet1Nhad"], "CJet1Nhad",3,0.5,3.5);
      book(_h["CJet1Nhad_1c"], "CJet1Nhad_1c",3,0.5,3.5);
      book(_h["CJet1Nhad_2c"], "CJet1Nhad_2c",3,0.5,3.5);
      book(_h["CJet1Ptfrac"], "CJet1Ptfrac",132,0.,1.32); 
      book(_h["CJet1Ptfrac_1had"], "CJet1Ptfrac_1had",132,0.,1.32);
      book(_h["CJet1Ptfrac_2had"], "CJet1Ptfrac_2had",132,0.,1.32);
      book(_h["CJet1Ptfrac_1c1had"], "CJet1Ptfrac_1c1had",132,0.,1.32);
      book(_h["CJet1Ptfrac_1c2had"], "CJet1Ptfrac_1c2had",132,0.,1.32); 
      book(_h["CJet1Ptfrac_1c"], "CJet1Ptfrac_1c",132,0.,1.32);
      book(_h["CJet1Ptfrac_2c"], "CJet1Ptfrac_2c",132,0.,1.32);
      book(_h["CJet1Ptfrac_2c1had"], "CJet1Ptfrac_2c1had",132,0.,1.32);
      book(_h["CJet1Ptfrac_2c2had"], "CJet1Ptfrac_2c2had",132,0.,1.32); 
      book(_h["CJet1Eta"], "CJet1Eta", 108, -2.7, 2.7);
      book(_h["CJet1Eta_1c"], "CJet1Eta_1c", 108, -2.7, 2.7);
      book(_h["CJet1Eta_2c"], "CJet1Eta_2c", 108, -2.7, 2.7);
      book(_h["CJet2Pt"], "CJet2Pt", 100, 0.0, 150.0);
      book(_h["CJet2Eta"], "CJet2Eta", 108, -2.7, 2.7);
      book(_h["CJet2Nhad"], "CJet2Nhad",3,0.5,3.5);
      book(_h["CJet2Ptfrac"], "CJet2Ptfrac",132,0.,1.32);
      book(_h["CJet2Ptfrac_1had"], "CJet2Ptfrac_1had",132,0.,1.32);
      book(_h["CJet2Ptfrac_2had"], "CJet2Ptfrac_2had",132,0.,1.32);
      book(_h["nCJets"], "nCJets", 4, 0.5, 4.5);
      book(_h["nCJets_fid"], "nCJets_fid", 4, 0.5, 4.5);
      book(_h["pTcc"],"pTcc", 80, 0.0, 400.0);
      book(_h["mcc"],"mcc", 100, 0.0, 400.0);
      book(_h["drcc"],"drcc",100,0.0, 5.0);
      
      book(_h["BJet1Pt"], "BJet1Pt", 100, 0.0, 400.0);
      book(_h["BJet2Pt"], "BJet2Pt", 100, 0.0, 250.0);
      book(_h["nBJets"], "nBJets", 5, -0.5, 4.5);
      book(_h["nBJets_1c"], "nBJets_1c", 5, -0.5, 4.5);
      book(_h["nBJets_2c"], "nBJets_2c", 5, -0.5, 4.5);
      book(_h["nJets"], "nJets", 12, -0.5, 11.5);
      book(_h["nJets_1c"], "nJets_1c", 12, -0.5, 11.5);
      book(_h["nJets_2c"], "nJets_2c", 12, -0.5, 11.5);

      book(_h["nLeptons"], "nLeptons", 5, -0.5, 4.5);
      book(_h["nLightLeptons"], "nLightLeptons", 4, -0.5, 3.5);
      book(_h["nTaus"], "nTaus", 4, -0.5, 3.5);
      book(_h["Lep1pt"], "Lep1pt", 100, 0.0, 250.0);
      book(_h["Lep2pt"], "Lep2pt", 100, 0.0, 150.0);
      book(_h["MET"], "MET", 100, 0.0, 300.0);

      
    }


    /// Perform the per-event analysis
    void analyze(const Event& event) {

      _h["total"]->fill(1.0);
      
      // Retrieve clustered jets, sorted by pT, with a minimum pT cut
      Jets jets = apply<FastJets>(event, "jets").jetsByPt(Cuts::pT > 15*GeV && Cuts::abseta < 2.5);

      Jets cjets = filter_select(jets, [](const Jet& jet) {
	if(jet.bTagged(Cuts::pT > 5*GeV)) return false;
	return  jet.cTagged(Cuts::pT > 5*GeV);
      });

      //require at least 1 c-jet
      if( cjets.size() < 1 ) return;
      _h["nCJets"]->fill(cjets.size());
      
      // Select jets ghost-associated to B-hadrons with a certain fiducial selection
      Jets bjets = filter_select(jets, [](const Jet& jet) {
	return  jet.bTagged(Cuts::pT > 5*GeV);
      });


      // Retrieve dressed leptons, sorted by pT. Also taus
      vector<DressedLepton> lightleps = apply<DressedLeptons>(event, "lightleptons").dressedLeptons();
      const Particles taus = apply<TauFinder>(event, "taus").taus();

      //Remove leptons within 0.4 of jets.
      idiscardIfAnyDeltaRLess(lightleps, jets, 0.4);
      
      int nleptons = lightleps.size() + taus.size(); //this includes double-counting though. to figure  out if i ever really care about such plots.
      _h["nLeptons"]->fill( nleptons );
      _h["nLightLeptons"]->fill(lightleps.size());
      _h["nTaus"]->fill( taus.size());

      //if( electrons.size() + muons.size() < 1 ) return;
      float lep1pt = 0;
      float lep2pt = 0;
      if(lightleps.size() > 0) lep1pt = lightleps[0].pT()/GeV;
      if(lightleps.size() > 1) lep2pt = lightleps[1].pT()/GeV;
      
      //if(lep.pt() < 27*GeV) return;

      _h["nJets"]->fill(jets.size());
      _h["nBJets"]->fill(bjets.size());
      //if( bjets.size() < 1 ) return;

      Particles chads1 = cjets[0].cTags(Cuts::pT > 5*GeV);
      float ptfrac1 = 0.0;
      for(int i = 0; i < chads1.size(); i++){
	ptfrac1 += chads1[i].pT()/cjets[0].pT();
      }
      
      _h["CJet1Pt"]->fill(cjets[0].pT()/GeV);
      _h["CJet1Eta"]->fill(cjets[0].eta());
      _h["CJet1Nhad"]->fill(chads1.size());
      _h["CJet1Ptfrac"]->fill(ptfrac1);
      if(chads1.size() == 1) _h["CJet1Ptfrac_1had"]->fill(ptfrac1);
      if(chads1.size() > 1)  _h["CJet1Ptfrac_2had"]->fill(ptfrac1);
      
      MissingMomentum met = apply<MissingMomentum>(event, "MET");
      Vector3 metvec = met.vectorMPT();
      _h["MET"]->fill(metvec.perp());
      if(lightleps.size() > 0) _h["Lep1pt"]->fill(lep1pt);
      if(lightleps.size() > 1) _h["Lep2pt"]->fill(lep2pt);

      if(bjets.size() > 0) _h["BJet1Pt"]->fill(bjets[0].pT()/GeV);
      if( bjets.size() >= 2 ){ 
	_h["BJet2Pt"]->fill(bjets[1].pT()/GeV);
      }

      if( cjets.size() == 1 ){
	_h["nJets_1c"]->fill(jets.size());
	_h["nBJets_1c"]->fill(bjets.size());
	_h["CJet1Pt_1c"]->fill(cjets[0].pT()/GeV);
	_h["CJet1Eta_1c"]->fill(cjets[0].eta());
	_h["CJet1Nhad_1c"]->fill(chads1.size());
	_h["CJet1Ptfrac_1c"]->fill(ptfrac1);
	if(chads1.size() == 1) _h["CJet1Ptfrac_1c1had"]->fill(ptfrac1);
	if(chads1.size() > 1)  _h["CJet1Ptfrac_1c2had"]->fill(ptfrac1);
      }
      
      //c jets
      if( cjets.size() >= 2 ){
	_h["CJet2Pt"]->fill(cjets[1].pT()/GeV);
	_h["CJet2Eta"]->fill(cjets[1].eta());
	
	auto c1 = cjets[0].momentum();
	auto c2 = cjets[1].momentum();
	float ccDR = Rivet::deltaR(c1, c2);
	_h["drcc"]->fill(ccDR);
	auto cc = c1.operator+=(c2);
	float ccMass = cc.mass();
	float ccpT = cc.pT();
	_h["pTcc"]->fill(ccpT);
	_h["mcc"]->fill(ccMass);

	Particles chads2 = cjets[1].cTags(Cuts::pT > 5*GeV);
	float ptfrac2 = 0.0;
	for(int i = 0; i < chads2.size(); i++){
	  ptfrac2 += chads2[i].pT()/cjets[1].pT();
	}
      
	_h["CJet2Nhad"]->fill(chads2.size());
	_h["CJet2Ptfrac"]->fill(ptfrac2);
	if(chads2.size() == 1) _h["CJet2Ptfrac_1had"]->fill(ptfrac2);
	if(chads2.size() > 1)  _h["CJet2Ptfrac_2had"]->fill(ptfrac2);
	
	_h["nJets_2c"]->fill(jets.size());
	_h["nBJets_2c"]->fill(bjets.size());
	_h["CJet1Pt_2c"]->fill(cjets[0].pT()/GeV);
	_h["CJet1Eta_2c"]->fill(cjets[0].eta());
	_h["CJet1Nhad_2c"]->fill(chads1.size());
	_h["CJet1Ptfrac_2c"]->fill(ptfrac1);
	if(chads1.size() == 1) _h["CJet1Ptfrac_2c1had"]->fill(ptfrac1);
	if(chads1.size() > 1)  _h["CJet1Ptfrac_2c2had"]->fill(ptfrac1);

      }

      //Apply the tt+cc XS fiducial selection, including a cutflow.

      _h["cutflow"]->fill(0);
      if(lightleps.size() != 2) return;
      _h["cutflow"]->fill(1);
      if(lightleps[0].pT() <27*GeV) return;
      _h["cutflow"]->fill(2);
      if(fabs(lightleps[0].pid()) == fabs(lightleps[1].pid())){
	auto l1 = lightleps[0].momentum();
	auto l2 = lightleps[1].momentum();
	auto ll = l1.operator+=(l2);
	float llMass = ll.mass();
	if(llMass/GeV < 15) return;
	if(llMass/GeV > 83 && llMass/GeV < 99) return;
      }
      _h["cutflow"]->fill(3);
      
      if(bjets.size() < 2) return;
      _h["cutflow"]->fill(4);
      if(bjets[1].pT() < 25*GeV) return;
      _h["cutflow"]->fill(5);
      if(jets.size() < 3) return;
      _h["cutflow"]->fill(6);
      if(jets[2].pT() < 25*GeV) return;
      _h["cutflow"]->fill(7);

      _h["nCJets_fid"]->fill(cjets.size());

      
    }
    

    /// Normalise histograms etc., after the run
    void finalize() {

      // normalize(_h["BJet1Pt"]); // normalize to unity
      // normalize(_h["BJet2Pt"]);
      
    }

    //@}


    /// @name Histograms
    //@{
    map<string, Histo1DPtr> _h;
    // map<string, Profile1DPtr> _p;
    // map<string, CounterPtr> _c;
    //@}
    
  };


  DECLARE_RIVET_PLUGIN(ttcc_plots);

}
